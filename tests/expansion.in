# Test expansion of variables

# We don't use the test utility function of the same name because we want
# different behavior. Specifically, that the expansion of any variables or
# other strings before we are invoked produce the expected expansion.
function expansion --description 'Prints argument count followed by arguments'
    echo (count $argv) $argv
end

set -l foo
expansion "$foo"
expansion $foo
expansion "prefix$foo"
expansion prefix$foo

expansion "$$foo"
expansion $$foo
expansion "prefix$$foo"
expansion prefix$$foo

set -l foo ''
expansion "$foo"
expansion $foo
expansion "prefix$foo"
expansion prefix$foo

expansion "$$foo"
expansion $$foo
expansion "prefix$$foo"
expansion prefix$$foo

set -l foo bar
set -l bar
expansion "$$foo"
expansion $$foo
expansion "prefix$$foo"
expansion prefix$$foo

set -l bar baz
expansion "$$foo"
expansion $$foo
expansion "prefix$$foo"
expansion prefix$$foo

set -l bar baz quux
expansion "$$foo"
expansion $$foo
expansion "prefix$$foo"
expansion prefix$$foo

set -l foo bar fooer fooest
set -l fooer
set -l fooest
expansion "$$foo"
expansion $$foo
expansion "prefix$$foo"
expansion prefix$$foo

set -l fooer ''
expansion $$foo
expansion prefix$$foo

set -l foo bar '' fooest
expansion "$$foo"
expansion $$foo
expansion "prefix$$foo"
expansion prefix$$foo
expansion $foo[-5..2] # No result, because the starting index is invalid and we force-reverse.
expansion $foo[-2..-1]
expansion $foo[-10..-5]
expansion (printf '%s\n' $foo)[-5..2]
expansion (printf '%s\n' $foo)[-2..-1]
expansion (printf '%s\n' $foo)[-10..-5]
expansion (echo one)[2..-1]

echo "# foo = "
set -l foo
expansion "$foo[1]"
expansion $foo[1]
expansion "$foo[-1]"
expansion $foo[-1]
expansion "$foo[2]"
expansion $foo[2]
expansion "$foo[1 2]"
expansion $foo[1 2]
expansion "$foo[2 1]"
expansion $foo[2 1]
echo "# foo = a b c"
set -l foo a b c
expansion $foo[17]
expansion $foo[-17]
expansion $foo[17..18]
expansion $foo[4..-2]
echo "# foo = a"
set -l foo a
expansion $foo[2..-1]

echo "$foo[d]"
echo $foo[d]

echo ()[1]
echo ()[d]

logmsg Catch your breath
set paren ')'
echo $$paren

logmsg Test tilde expansion
# On OS X, /tmp is symlinked to /private/tmp
# $PWD is our best bet for resolving it
set -l saved $PWD
cd (mktemp -d)
set tmpdir $PWD
cd $saved
mkdir $tmpdir/realhome
ln -s $tmpdir/realhome $tmpdir/linkhome
set expandedtilde (env HOME=$tmpdir/linkhome ../test/root/bin/fish -c 'echo ~')
if test $expandedtilde != $tmpdir/realhome
	echo '~ expands to' $expandedtilde ' - expected ' $tmpdir/realhome
end
unlink $tmpdir/linkhome
rmdir $tmpdir/realhome
rmdir $tmpdir

logmsg Test delimiters
set TEST_DELIMITER one two three
set TEST_DELIMITER_PATH one two three
echo TEST_DELIMITER: $TEST_DELIMITER "$TEST_DELIMITER"
echo TEST_DELIMITER_PATH: $TEST_DELIMITER_PATH "$TEST_DELIMITER_PATH"
echo "Delimiters: " (set --print-delimiter TEST_DELIMITER) (set --print-delimiter TEST_DELIMITER_PATH)
set -g --delimit '!' delimited 1 2 3
echo delimited 1: "$delimited"
set -g delimited 4 5 6
echo delimited 2: "$delimited"

function delimit_test
  echo "Entering delimit function"
  # Local delimited value should inherit global delimiter
  set -l delimited 7 8 9
  echo "$delimited"
  # Modifying local should not affect global
  set --delimit @ delimited 11 12 13
  echo "$delimited"
  echo local: (set --print-delimiter delimited) global: (set --print-delimiter -g delimited)
end
delimit_test
echo now global: (set --print-delimiter -g delimited)
# Ensure sketchy delimiters are supported.
set --delimit \n'*\\' delimited 14 15 16
echo (set --print-delimiter delimited) "$delimited"
